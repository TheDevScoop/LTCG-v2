import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema(
  {
    users: defineTable({
      privyId: v.string(),
      username: v.string(),
      email: v.optional(v.string()),
      name: v.optional(v.string()),
      telegramUserId: v.optional(v.string()),
      avatarPath: v.optional(v.string()),
      // String ID referencing a userDecks doc in the cards component.
      // Stored as string because host schema can't reference component table types.
      activeDeckId: v.optional(v.string()),
      // Clique membership
      cliqueId: v.optional(v.id("cliques")),
      cliqueRole: v.optional(v.union(v.literal("member"), v.literal("leader"), v.literal("founder"))),
      createdAt: v.number(),
    })
      .index("by_privyId", ["privyId"])
      .index("by_username", ["username"])
      .index("by_clique", ["cliqueId"])
      .index("by_telegramUserId", ["telegramUserId"]),

    agents: defineTable({
      name: v.string(),
      apiKeyHash: v.string(),
      apiKeyPrefix: v.string(),
      userId: v.id("users"),
      isActive: v.boolean(),
      createdAt: v.number(),
    })
      .index("by_apiKeyHash", ["apiKeyHash"])
      .index("by_userId", ["userId"]),

    // Links match component matches to story context.
    // The match component schema is strict, so story metadata lives here.
    storyMatches: defineTable({
      matchId: v.string(),
      userId: v.string(),
      chapterId: v.string(),
      stageNumber: v.number(),
      stageId: v.string(),
      outcome: v.optional(
        v.union(v.literal("won"), v.literal("lost"), v.literal("abandoned")),
      ),
      starsEarned: v.optional(v.number()),
      rewardsGold: v.optional(v.number()),
      rewardsXp: v.optional(v.number()),
      firstClearBonus: v.optional(v.number()),
      completedAt: v.optional(v.number()),
    })
      .index("by_matchId", ["matchId"])
      .index("by_userId", ["userId"]),

    // PvP lobby metadata (host-layer only). Match state still lives in the
    // match component; this table adds visibility + join-code routing.
    pvpLobbies: defineTable({
      matchId: v.string(),
      mode: v.literal("pvp"),
      hostUserId: v.string(),
      hostUsername: v.string(),
      visibility: v.union(v.literal("public"), v.literal("private")),
      joinCode: v.optional(v.string()),
      status: v.union(
        v.literal("waiting"),
        v.literal("active"),
        v.literal("ended"),
        v.literal("canceled"),
      ),
      createdAt: v.number(),
      activatedAt: v.optional(v.number()),
      endedAt: v.optional(v.number()),
      pongEnabled: v.optional(v.boolean()),
      redemptionEnabled: v.optional(v.boolean()),
    })
      .index("by_matchId", ["matchId"])
      .index("by_hostUserId", ["hostUserId"])
      .index("by_joinCode", ["joinCode"])
      .index("by_status", ["status"]),

    // Presence + platform markers for active matches.
    // Used to show whether players are on web/telegram/discord/etc.
    matchPresence: defineTable({
      matchId: v.string(),
      userId: v.string(),
      platform: v.union(
        v.literal("web"),
        v.literal("telegram"),
        v.literal("discord"),
        v.literal("embedded"),
        v.literal("agent"),
        v.literal("cpu"),
        v.literal("unknown"),
      ),
      source: v.optional(v.string()),
      lastSeenAt: v.number(),
      createdAt: v.number(),
    })
      .index("by_match", ["matchId"])
      .index("by_user", ["userId"])
      .index("by_match_user", ["matchId", "userId"]),

    // Singleton — tracks current position in the 16-week campaign.
    // One row. Created by seed, advanced by cron.
    campaignState: defineTable({
      weekNumber: v.number(), // 1–16
      dayOfWeek: v.number(), // 1–5 (Mon–Fri school days)
      actNumber: v.number(), // 1–4
      isActive: v.boolean(),
      startedAt: v.number(),
      lastAdvancedAt: v.number(),
    }),

    // Persisted daily briefing content generated by cron.
    // One row per campaign day. Content type rotates by dayOfWeek:
    // 1=spotlight, 2=tip, 3=meta, 4=lore, 5=recap
    dailyBriefings: defineTable({
      weekNumber: v.number(),
      dayOfWeek: v.number(),
      actNumber: v.number(),
      contentType: v.union(
        v.literal("archetype_spotlight"),
        v.literal("card_tip"),
        v.literal("meta_report"),
        v.literal("lore_tidbit"),
        v.literal("weekly_recap"),
      ),
      title: v.string(),
      body: v.string(),
      archetype: v.optional(v.string()),
      cardName: v.optional(v.string()),
      createdAt: v.number(),
    })
      .index("by_week_day", ["weekNumber", "dayOfWeek"])
      .index("by_createdAt", ["createdAt"]),

    // Tracks daily agent check-ins so we know who's seen today's briefing.
    agentCheckins: defineTable({
      agentId: v.id("agents"),
      userId: v.id("users"),
      weekNumber: v.number(),
      dayOfWeek: v.number(),
      checkedInAt: v.number(),
    })
      .index("by_agent_day", ["agentId", "weekNumber", "dayOfWeek"])
      .index("by_userId", ["userId"]),

    // Cliques - one per archetype
    cliques: defineTable({
      name: v.string(),           // e.g., "Honor Club"
      archetype: v.string(),      // dropouts, preps, geeks, freaks, nerds, goodies
      description: v.string(),
      iconUrl: v.optional(v.string()),
      memberCount: v.number(),
      totalWins: v.number(),
      createdAt: v.number(),
    })
      .index("by_archetype", ["archetype"]),

    // Telegram identity linking (maps Telegram users to LTCG users)
    telegramIdentities: defineTable({
      userId: v.string(),
      telegramUserId: v.string(),
      username: v.optional(v.string()),
      firstName: v.optional(v.string()),
      privateChatId: v.optional(v.string()),
      lastSeenAt: v.number(),
      linkedAt: v.number(),
    })
      .index("by_userId", ["userId"])
      .index("by_telegramUserId", ["telegramUserId"]),

    // One-time action tokens for Telegram inline buttons
    telegramActionTokens: defineTable({
      token: v.string(),
      matchId: v.string(),
      seat: v.union(v.literal("host"), v.literal("away")),
      commandJson: v.string(),
      expectedVersion: v.optional(v.number()),
      expiresAt: v.number(),
      createdAt: v.number(),
    }).index("by_token", ["token"]),

    // Idempotency guard for Telegram webhook updates
    telegramProcessedUpdates: defineTable({
      updateId: v.number(),
      processedAt: v.number(),
    }).index("by_updateId", ["updateId"]),

    // Player economy + progression stats (one row per user)
    playerStats: defineTable({
      userId: v.id("users"),
      gold: v.number(),
      xp: v.number(),
      level: v.number(),
      totalWins: v.number(),
      totalLosses: v.number(),
      pvpWins: v.number(),
      pvpLosses: v.number(),
      storyWins: v.number(),
      currentStreak: v.number(),
      bestStreak: v.number(),
      totalMatchesPlayed: v.number(),
      dailyLoginStreak: v.number(),
      lastLoginBonusAt: v.optional(v.number()),
      lastMatchAt: v.optional(v.number()),
      createdAt: v.number(),
    })
      .index("by_userId", ["userId"])
      .index("by_gold", ["gold"])
      .index("by_xp", ["xp"])
      .index("by_level", ["level"]),

    // ELO rating system for ranked PvP matches
    playerRatings: defineTable({
      userId: v.id("users"),
      rating: v.number(),         // Start at 1000
      peakRating: v.number(),
      tier: v.union(
        v.literal("bronze"),
        v.literal("silver"),
        v.literal("gold"),
        v.literal("platinum"),
        v.literal("diamond"),
      ),
      gamesPlayed: v.number(),
      seasonId: v.optional(v.string()),
      ratingHistory: v.array(v.object({
        rating: v.number(),
        change: v.number(),
        opponentRating: v.number(),
        result: v.union(v.literal("win"), v.literal("loss")),
        timestamp: v.number(),
      })),
      updatedAt: v.number(),
      createdAt: v.number(),
    })
      .index("by_userId", ["userId"])
      .index("by_rating", ["rating"])
      .index("by_tier", ["tier"]),

    // Match history for win/loss tracking with rating changes
    matchHistory: defineTable({
      matchId: v.string(),
      mode: v.union(v.literal("pvp"), v.literal("story"), v.literal("ranked")),
      winnerId: v.id("users"),
      loserId: v.id("users"),
      winnerRatingBefore: v.optional(v.number()),
      loserRatingBefore: v.optional(v.number()),
      ratingChange: v.optional(v.number()),
      duration: v.optional(v.number()),
      timestamp: v.number(),
    })
      .index("by_matchId", ["matchId"])
      .index("by_winnerId", ["winnerId"])
      .index("by_loserId", ["loserId"])
      .index("by_timestamp", ["timestamp"]),

    // Ranked matchmaking queue — automatic rating-based pairing
    rankedQueue: defineTable({
      userId: v.id("users"),
      rating: v.number(),
      deckId: v.string(),
      status: v.union(v.literal("waiting"), v.literal("matched"), v.literal("expired")),
      matchId: v.optional(v.string()),
      joinedAt: v.number(),
      matchedAt: v.optional(v.number()),
    }).index("by_userId", ["userId"])
      .index("by_userId_status", ["userId", "status"])
      .index("by_status", ["status"])
      .index("by_status_rating", ["status", "rating"]),

    // Stream chat — agent messages displayed on stream overlay + spectator views.
    // Written by the agent plugin via HTTP API; subscribed to by the frontend overlay.
    streamMessages: defineTable({
      agentId: v.id("agents"),
      role: v.union(v.literal("agent"), v.literal("viewer"), v.literal("system")),
      senderName: v.string(),
      text: v.string(),
      source: v.union(
        v.literal("retake"),
        v.literal("telegram"),
        v.literal("discord"),
        v.literal("system"),
        v.literal("other"),
      ),
      createdAt: v.number(),
    })
      .index("by_agent", ["agentId"])
      .index("by_agent_created", ["agentId", "createdAt"]),

    // Agent telemetry — per-agent win/loss and match statistics
    agentStats: defineTable({
      agentId: v.id("agents"),
      matchesPlayed: v.number(),
      wins: v.number(),
      losses: v.number(),
      avgTurnsPerMatch: v.number(),
      totalTurns: v.number(),
      favoriteArchetype: v.optional(v.string()),
      agentVsHumanWins: v.number(),
      agentVsHumanLosses: v.number(),
      agentVsAgentWins: v.number(),
      agentVsAgentLosses: v.number(),
      lastMatchAt: v.optional(v.number()),
      createdAt: v.number(),
      updatedAt: v.number(),
    }).index("by_agentId", ["agentId"])
      .index("by_wins", ["wins"]),
  },
  { schemaValidation: false },
);
